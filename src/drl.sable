Package drlc;

Helpers
	all = [0 .. 127];
	digit = ['0' .. '9'];
	letter = [['a' .. 'z'] + ['A' .. 'Z']];
	
	decimal_integer = (digit | '_')* digit (digit | '_')*;
	binary_digit = '0' | '1';
	binary_integer = ('0b' | '0B') (binary_digit | '_')* binary_digit (binary_digit | '_')*;
	octal_digit = ['0' .. '7'];
	octal_integer = ('0o' | '0O') (octal_digit | '_')* octal_digit (octal_digit | '_')*;
	hexadecimal_digit = [digit + [['a' .. 'f'] + ['A' .. 'F']]];
	hexadecimal_integer = ('0x' | '0X') (hexadecimal_digit | '_')* hexadecimal_digit (hexadecimal_digit | '_')*;
	integer = decimal_integer | binary_integer | octal_integer | hexadecimal_integer;
	
	lf = 10;
	cr = 13;
	eol = lf | cr lf?;
	
	apostrophe = 39;
	quote = 34;
	
	hex_escape = 'x' octal_digit hexadecimal_digit;
	escape_char = '\' ('0' | 't' | 'b' | 'n' | 'r' | 'f' | apostrophe | quote | '\' | hex_escape);
	
	c_char = [all - [apostrophe + ['\' + [lf + cr]]]] | escape_char;
	
	s_char = [all - [quote + ['\' + [lf + cr]]]] | escape_char;
	s_char_sequence = s_char*;
	
	not_eol = [all - [lf + cr]];
	not_star = [all - '*'];
	not_star_slash = [not_star - '/'];
	
	line_comment = '//' not_eol* eol?;
	block_comment = '/*' not_star* '*'+ (not_star_slash not_star* '*'+)* '/';

Tokens
	directive_prefix = '%!';
	
	typealias = 'typealias';
	struct = 'struct';
	
	fn = 'fn';
	const = 'const';
	let = 'let';
	
	static = 'static';
	mut = 'mut';
	
	arrow = '->';
	
	conditional_branch_keyword = 'if' | 'unless';
	else = 'else';
	
	loop = 'loop';
	conditional_iterative_keyword = 'while' | 'until';
	do = 'do';
	
	exit = 'exit';
	return = 'return';
	continue = 'continue';
	break = 'break';
	
	sizeof = 'sizeof';
	
	l_par = '(';
	r_par = ')';
	l_bracket = '[';
	r_bracket = ']';
	l_brace = '{';
	r_brace = '}';
	comma = ',';
	colon = ':';
	semicolon = ';';
	full_stop = '.';
	question_mark = '?';
	
	equals = '=';
	
	plus_equals = '+=';
	and_equals = '&=';
	or_equals = '|=';
	xor_equals = '^=';
	minus_equals = '-=';
	
	left_shift_equals = '<<=';
	right_shift_equals = '>>=';
	left_rotate_equals = '<<<=';
	right_rotate_equals = '>>>=';
	
	multiply_equals = '*=';
	divide_equals = '/=';
	remainder_equals = '%=';
	
	logical_and = '&&';
	logical_or = '||';
	
	equal_to = '==';
	not_equal_to = '!=';
	
	less_than = '<';
	less_or_equal = '<=';
	more_than = '>';
	more_or_equal = '>=';
	
	plus = '+';
	and = '&';
	or = '|';
	xor = '^';
	minus = '-';
	
	left_shift = '<<';
	right_shift = '>>';
	left_rotate = '<<<';
	right_rotate = '>>>';
	
	multiply = '*';
	divide = '/';
	remainder = '%';
	
	not = '!';
	
	bool_value = 'false' | 'true';
	
	name = (letter | '_') (digit | letter | '_')*;
	
	int_value = integer ('I' | 'i')?;
	nat_value = integer ('N' | 'n');
	
	char_value = apostrophe c_char apostrophe;
	
	blank = (' ' | 9 | 11 | eol)+;
	comment = line_comment | block_comment;

Ignored Tokens
	blank,
	comment;

Productions
	unit =
		setup program;
	
	setup =
		directive*;
	
	program =
		static_section*;
	
	
	
	/* UNIT SPECIFICATION */
	
	directive =
		directive_prefix name expression_list? semicolon;
	
	static_section =
		{function_definition} function_definition |
		{typealias_definition} typealias_definition |
		{struct_definition} struct_definition |
		{constant_definition} constant_definition |
		{variable_declaration} variable_declaration |
		{empty_section} empty_section;
	
	runtime_section =
		{static_section} static_section |
		{scoped_section} scoped_section |
		{expression_statement} expression_statement |
		{conditional_section} conditional_section |
		{iterative_section} iterative_section;
	
	
	
	/* SECTION SPECIFICATIONS */
	
	function_definition =
		fn name l_par declarator_list? r_par return_type? l_brace scoped_body r_brace;
	
	typealias_definition =
		typealias name equals type semicolon;
	
	struct_definition =
		struct name l_brace declarator_list? r_brace;
	
	constant_definition =
		const name type_annotation? equals constant_expression semicolon;
	
	variable_declaration =
		{excluding_initialization} let declarator semicolon |
		{including_initialization} let declarator equals expression semicolon;
	
	empty_section =
		semicolon;
	
	scoped_section =
		l_brace scoped_body r_brace;
	
	expression_statement =
		expression semicolon;
	
	conditional_section =
		conditional_branch_keyword condition_expression l_brace scoped_body r_brace else_section?;
	
	else_section =
		{excluding_branch} else l_brace scoped_body r_brace |
		{including_branch} else conditional_section;
	
	iterative_section =
		{loop} label? loop l_brace scoped_body r_brace |
		{conditional} label? conditional_iterative_keyword condition_expression l_brace scoped_body r_brace |
		{do_conditional} label? do l_brace scoped_body r_brace conditional_iterative_keyword expression semicolon;
	
	scoped_body =
		runtime_section* stop_statement?;
	
	stop_statement =
		{exit} exit expression? semicolon dead_section* |
		{return} return expression? semicolon dead_section* |
		{continue} continue name? semicolon dead_section* |
		{break} break name? semicolon dead_section*;
	
	dead_section =
		{dead0} runtime_section |
		{dead1} exit expression? semicolon |
		{dead2} return expression? semicolon |
		{dead3} continue name? semicolon |
		{dead4} break name? semicolon;
	
	
	
	/* COMPONENT SPECIFICATIONS */
	
	type =
		{raw} raw_type |
		{address_of} and mut? type |
		{double_address_of} logical_and mut? type;
	
	raw_type =
		{nominal} name |
		{array} l_bracket type semicolon constant_expression r_bracket |
		{tuple} l_par tuple_type_list? r_par |
		{function} fn l_par type_list? r_par return_type?;
	
	tuple_type_list =
		type comma type_list?;
	
	type_list =
		type type_list_tail* comma?;
	
	type_list_tail =
		comma type;
	
	return_type =
		arrow type;
	
	type_annotation =
		colon type;
	
	declarator =
		variable_modifier* name type_annotation?;
	
	variable_modifier =
		{static} static |
		{mut} mut;
	
	declarator_list =
		declarator declarator_list_tail* comma?;
	
	declarator_list_tail =
		comma declarator;
	
	label =
		name colon;
	
	expression =
		{prioritized} ternary_expression |
		{assignment} unary_expression assignment_op expression;
	
	ternary_expression =
		{prioritized} logical_expression |
		{ternary} logical_expression question_mark expression colon ternary_expression;
	
	logical_expression =
		{prioritized} equality_expression |
		{binary} logical_expression logical_binary_op equality_expression;
	
	equality_expression =
		{prioritized} comparative_expression |
		{binary} equality_expression equality_binary_op comparative_expression;
	
	comparative_expression =
		{prioritized} additive_expression |
		{binary} comparative_expression comparative_binary_op additive_expression;
	
	additive_expression =
		{prioritized} multiplicative_expression |
		{binary} additive_expression additive_binary_op multiplicative_expression;
	
	multiplicative_expression =
		{prioritized} shift_expression |
		{binary} multiplicative_expression multiplicative_binary_op shift_expression;
	
	shift_expression =
		{prioritized} unary_expression |
		{binary} shift_expression shift_binary_op unary_expression;
	
	unary_expression =
		{prioritized} compound_expression |
		{unary} unary_op unary_expression |
		{dereference} multiply unary_expression |
		{address_of} and mut? unary_expression |
		{double_address_of} logical_and mut? unary_expression;
	
	compound_expression =
		{parentheses} parentheses_expression |
		{simple} simple_expression |
		{array_list} l_bracket expression_list? r_bracket |
		{array_repeat} l_bracket expression semicolon constant_expression r_bracket |
		{index} compound_expression l_bracket expression r_bracket |
		{tuple} l_par tuple_expression_list? r_par |
		{struct} name l_brace struct_expression_list? r_brace |
		{member} compound_expression full_stop simple_expression |
		{function} compound_expression l_par expression_list? r_par;
	
	parentheses_expression =
		l_par expression r_par;
	
	simple_expression =
		{value} value |
		{variable} name;
	
	expression_list =
		expression expression_list_tail* comma?;
	
	expression_list_tail =
		comma expression;
	
	tuple_expression_list =
		expression comma expression_list?;
	
	struct_expression_list =
		{basic} expression_list |
		{labelled} labelled_expression_list;
	
	labelled_expression_list =
		labelled_expression labelled_expression_list_tail* comma?;
	
	labelled_expression_list_tail =
		comma labelled_expression;
	
	labelled_expression =
		label expression;
	
	value =
		{bool} bool_value |
		{int} int_value |
		{nat} nat_value |
		{char} char_value |
		{sizeof} sizeof type;
	
	constant_expression =
		expression;
	
	condition_expression =
		{prioritized} condition_ternary_expression |
		{assignment} condition_unary_expression assignment_op condition_expression;
	
	condition_ternary_expression =
		{prioritized} condition_logical_expression |
		{ternary} condition_logical_expression question_mark expression colon condition_ternary_expression;
	
	condition_logical_expression =
		{prioritized} condition_equality_expression |
		{binary} condition_logical_expression logical_binary_op condition_equality_expression;
	
	condition_equality_expression =
		{prioritized} condition_comparative_expression |
		{binary} condition_equality_expression equality_binary_op condition_comparative_expression;
	
	condition_comparative_expression =
		{prioritized} condition_additive_expression |
		{binary} condition_comparative_expression comparative_binary_op condition_additive_expression;
	
	condition_additive_expression =
		{prioritized} condition_multiplicative_expression |
		{binary} condition_additive_expression additive_binary_op condition_multiplicative_expression;
	
	condition_multiplicative_expression =
		{prioritized} condition_shift_expression |
		{binary} condition_multiplicative_expression multiplicative_binary_op condition_shift_expression;
	
	condition_shift_expression =
		{prioritized} condition_unary_expression |
		{binary} condition_shift_expression shift_binary_op condition_unary_expression;
	
	condition_unary_expression =
		{prioritized} condition_compound_expression |
		{unary} unary_op condition_unary_expression |
		{dereference} multiply condition_unary_expression |
		{address_of} and mut? condition_unary_expression |
		{double_address_of} logical_and mut? condition_unary_expression;
	
	condition_compound_expression =
		{parentheses} parentheses_expression |
		{simple} simple_expression |
		{array_list} l_bracket expression_list? r_bracket |
		{array_repeat} l_bracket expression semicolon constant_expression r_bracket |
		{index} condition_compound_expression l_bracket expression r_bracket |
		{tuple} l_par tuple_expression_list? r_par |
		{member} condition_compound_expression full_stop simple_expression |
		{function} condition_compound_expression l_par expression_list? r_par;
	
	
	
	/* OPERATION SPECIFICATIONS */
	
	assignment_op =
		{equals} equals |
		{plus} plus_equals |
		{and} and_equals |
		{or} or_equals |
		{xor} xor_equals |
		{minus} minus_equals |
		{multiply} multiply_equals |
		{divide} divide_equals |
		{remainder} remainder_equals |
		{left_shift} left_shift_equals |
		{right_shift} right_shift_equals |
		{left_rotate} left_rotate_equals |
		{right_rotate} right_rotate_equals;
	
	logical_binary_op =
		{logical_and} logical_and |
		{logical_or} logical_or;
	
	equality_binary_op =
		{equal_to} equal_to |
		{not_equal_to} not_equal_to;
	
	comparative_binary_op =
		{less_than} less_than |
		{less_or_equal} less_or_equal |
		{more_than} more_than |
		{more_or_equal} more_or_equal;
	
	additive_binary_op =
		{plus} plus |
		{and} and |
		{or} or |
		{xor} xor |
		{minus} minus;
	
	multiplicative_binary_op =
		{multiply} multiply |
		{divide} divide |
		{remainder} remainder;
	
	shift_binary_op =
		{left_shift} left_shift |
		{right_shift} right_shift |
		{left_rotate} left_rotate |
		{right_rotate} right_rotate;
	
	unary_op =
		{minus} minus |
		{not} not;
