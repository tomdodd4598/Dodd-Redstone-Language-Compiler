Package drlc;

Helpers
	all = [0 .. 127];
	digit = ['0' .. '9'];
	letter = [['a' .. 'z'] + ['A' .. 'Z']];
	
	decimal_integer = (digit | '_')* digit (digit | '_')*;
	binary_digit = '0' | '1';
	binary_integer = ('0b' | '0B') (binary_digit | '_')* binary_digit (binary_digit | '_')*;
	octal_digit = ['0' .. '7'];
	octal_integer = ('0o' | '0O') (octal_digit | '_')* octal_digit (octal_digit | '_')*;
	hexadecimal_digit = [digit + [['a' .. 'f'] + ['A' .. 'F']]];
	hexadecimal_integer = ('0x' | '0X') (hexadecimal_digit | '_')* hexadecimal_digit (hexadecimal_digit | '_')*;
	integer = decimal_integer | binary_integer | octal_integer | hexadecimal_integer;
	
	lf = 10;
	cr = 13;
	eol = lf | cr lf?;
	
	apostrophe = 39;
	quote = 34;
	
	hex_escape = 'x' octal_digit hexadecimal_digit;
	escape_char = '\' ('0' | 't' | 'b' | 'n' | 'r' | 'f' | apostrophe | quote | '\' | hex_escape);
	
	c_char = [all - [apostrophe + ['\' + [lf + cr]]]] | escape_char;
	
	s_char = [all - [quote + ['\' + [lf + cr]]]] | escape_char;
	s_char_sequence = s_char*;
	
	not_eol = [all - [lf + cr]];
	not_star = [all - '*'];
	not_star_slash = [not_star - '/'];
	
	line_comment = '//' not_eol* eol?;
	block_comment = '/*' not_star* '*'+ (not_star_slash not_star* '*'+)* '/';

Tokens
	directive_prefix = '%!';
	
	variable_modifier = 'static' | 'mut';
	
	fn = 'fn';
	const = 'const';
	let = 'let';
	
	arrow = '->';
	
	conditional_branch_keyword = 'if' | 'unless';
	else = 'else';
	
	loop = 'loop';
	conditional_iterative_keyword = 'while' | 'until';
	do = 'do';
	
	exit = 'exit';
	return = 'return';
	continue = 'continue';
	break = 'break';
	
	sizeof = 'sizeof';
	
	l_par = '(';
	r_par = ')';
	l_bracket = '[';
	r_bracket = ']';
	l_brace = '{';
	r_brace = '}';
	comma = ',';
	colon = ':';
	semicolon = ';';
	
	equals = '=';
	
	plus_equals = '+=';
	and_equals = '&=';
	or_equals = '|=';
	xor_equals = '^=';
	minus_equals = '-=';
	
	left_shift_equals = '<<=';
	right_shift_equals = '>>=';
	left_rotate_equals = '<<<=';
	right_rotate_equals = '>>>=';
	
	multiply_equals = '*=';
	divide_equals = '/=';
	remainder_equals = '%=';
	
	logical_and = '&?';
	logical_or = '|?';
	
	equal_to = '==';
	not_equal_to = '!=';
	
	less_than = '<';
	less_or_equal = '<=';
	more_than = '>';
	more_or_equal = '>=';
	
	plus = '+';
	and = '&';
	or = '|';
	xor = '^';
	minus = '-';
	
	left_shift = '<<';
	right_shift = '>>';
	left_rotate = '<<<';
	right_rotate = '>>>';
	
	multiply = '*';
	divide = '/';
	remainder = '%';
	
	not = '!';
	
	bool_value = 'false' | 'true';
	
	name = letter (digit | letter | '_')*;
	discard = '_';
	
	int_value = integer ('I' | 'i')?;
	nat_value = integer ('N' | 'n');
	
	char_value = apostrophe c_char apostrophe;
	
	null = 'null';
	
	blank = (' ' | 9 | 11 | eol)+;
	comment = line_comment | block_comment;

Ignored Tokens
	blank,
	comment;

Productions
	unit =
		setup program;
	
	setup =
		directive*;
	
	program =
		program_section*;
	
	
	
	/* UNIT SPECIFICATION */
	
	directive =
		directive_prefix name expression_list? semicolon+;
	
	program_section =
		{function_definition} function_definition |
		{basic_section} basic_section;
	
	basic_section =
		{scoped_section} scoped_section |
		{constant_definition} constant_definition |
		{variable_declaration} variable_declaration |
		{expression_statement} expression_statement |
		{conditional_section} conditional_section |
		{iterative_section} iterative_section;
	
	
	
	/* SECTION SPECIFICATIONS */
	
	function_definition =
		fn name l_par parameter_list? r_par return_type? l_brace scope_contents r_brace;
	
	scoped_section =
		l_brace scope_contents r_brace;
	
	constant_definition =
		const name type_annotation equals constant_expression semicolon+;
	
	variable_declaration =
		{excluding_initialization} let variable_declarator semicolon+ |
		{including_initialization} let variable_declarator equals expression semicolon+;
	
	expression_statement =
		{basic} expression semicolon+ |
		{assignment} assignment_expression assignment_op expression semicolon+;
	
	conditional_section =
		conditional_branch_keyword expression l_brace scope_contents r_brace else_section?;
	
	else_section =
		{excluding_branch} else l_brace scope_contents r_brace |
		{including_branch} else conditional_section;
	
	iterative_section =
		{loop} iterative_section_label? loop l_brace scope_contents r_brace |
		{conditional} iterative_section_label? conditional_iterative_keyword expression l_brace scope_contents r_brace |
		{do_conditional} iterative_section_label? do l_brace scope_contents r_brace conditional_iterative_keyword expression semicolon+;
	
	scope_contents =
		basic_section* stop_statement?;
	
	stop_statement =
		{exit} exit expression? semicolon+ dead_section* |
		{return} return expression? semicolon+ dead_section* |
		{continue} continue name? semicolon+ dead_section* |
		{break} break name? semicolon+ dead_section*;
	
	dead_section =
		{dead0} basic_section |
		{dead1} exit expression? semicolon+ |
		{dead2} return expression? semicolon+ |
		{dead3} continue name? semicolon+ |
		{dead4} break name? semicolon+;
	
	
	
	/* COMPONENT SPECIFICATIONS */
	
	type =
		and* raw_type;
	
	raw_type =
		{basic} name |
		{array} l_bracket type semicolon constant_expression r_bracket |
		{function} fn l_par type_list? r_par return_type?;
	
	type_list =
		type type_list_tail* comma?;
	
	type_list_tail =
		comma type;
	
	return_type =
		arrow type;
	
	variable_declarator =
		variable_modifier* name type_annotation;
	
	type_annotation =
		colon type;
	
	parameter_list =
		parameter_declarator parameter_list_tail* comma?;
	
	parameter_list_tail =
		comma parameter_declarator;
	
	parameter_declarator =
		variable_modifier* identifier type_annotation;
	
	identifier =
		{name} name |
		{discard} discard;
	
	iterative_section_label =
		name colon;
	
	expression =
		expression0;
	
	constant_expression =
		expression0;
	
	assignment_expression =
		expression0;
	
	expression0 =
		{prioritized} expression1 |
		{binary} expression0 logical_binary_op expression1;
	
	expression1 =
		{prioritized} expression2 |
		{binary} expression1 equality_binary_op expression2;
	
	expression2 =
		{prioritized} expression3 |
		{binary} expression2 comparative_binary_op expression3;
	
	expression3 =
		{prioritized} expression4 |
		{binary} expression3 additive_binary_op expression4;
	
	expression4 =
		{prioritized} expression5 |
		{binary} expression4 shift_binary_op expression5;
	
	expression5 =
		{prioritized} expression6 |
		{binary} expression5 multiplicative_binary_op expression6;
	
	expression6 =
		{prioritized} expression7 |
		{unary} unary_op expression6 |
		{dereference} multiply expression6 |
		{address_of} and expression6;
	
	expression7 =
		{prioritized} expression8 |
		{array_list} l_bracket expression_list? r_bracket |
		{array_repeat} l_bracket expression semicolon constant_expression r_bracket |
		{index} expression7 l_bracket expression r_bracket |
		{function} expression7 l_par expression_list? r_par;
	
	expression_list =
		expression expression_list_tail* comma?;
	
	expression_list_tail =
		comma expression;
	
	expression8 =
		{value} value |
		{variable} name |
		{parentheses} l_par expression r_par;
	
	value =
		{bool} bool_value |
		{int} int_value |
		{nat} nat_value |
		{char} char_value |
		{null} null |
		{sizeof} sizeof type;
	
	
	
	/* OPERATION SPECIFICATIONS */
	
	assignment_op =
		{equals} equals |
		{plus} plus_equals |
		{and} and_equals |
		{or} or_equals |
		{xor} xor_equals |
		{minus} minus_equals |
		{left_shift} left_shift_equals |
		{right_shift} right_shift_equals |
		{left_rotate} left_rotate_equals |
		{right_rotate} right_rotate_equals |
		{multiply} multiply_equals |
		{divide} divide_equals |
		{remainder} remainder_equals;
	
	logical_binary_op =
		{logical_and} logical_and |
		{logical_or} logical_or;
	
	equality_binary_op =
		{equal_to} equal_to |
		{not_equal_to} not_equal_to;
	
	comparative_binary_op =
		{less_than} less_than |
		{less_or_equal} less_or_equal |
		{more_than} more_than |
		{more_or_equal} more_or_equal;
	
	additive_binary_op =
		{plus} plus |
		{and} and |
		{or} or |
		{xor} xor |
		{minus} minus;
	
	shift_binary_op =
		{left_shift} left_shift |
		{right_shift} right_shift |
		{left_rotate} left_rotate |
		{right_rotate} right_rotate;
	
	multiplicative_binary_op =
		{multiply} multiply |
		{divide} divide |
		{remainder} remainder;
	
	unary_op =
		{minus} minus |
		{not} not;
