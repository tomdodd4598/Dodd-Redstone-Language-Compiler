Package drlc;

Helpers
	all = [0 .. 0xFFFF];
	digit = ['0' .. '9'];
	letter = [['a' .. 'z'] + ['A' .. 'Z']];
	nondigit = ['_' + letter];
	char = digit | nondigit;
	sign = '-' | '+';
	
	tab = 9;
	lf = 10;
	cr = 13;
	eol = lf | cr | cr lf;
	separator = ' ' | tab | eol;
	
	double_slash = '//';
	slash_star = '/*';
	star_slash = '*/';
	
	not_eol = [all - [cr + lf]];
	not_star = [all - '*'];
	not_star_slash = [not_star - '/'];
	
	line_comment = double_slash not_eol* eol;
	block_comment = slash_star not_star* '*'+ (not_star_slash not_star* '*'+)* '/';

Tokens
	set_argc = 'set_argc';
	
	const = 'const';
	var = 'var';
	void = 'void';
	fun = 'fun';
	
	out = 'out';
	
	argc = 'argc';
	argv = 'argv';
	
	return = 'return';
	if = 'if';
	else = 'else';
	while = 'while';
	continue = 'continue';
	break = 'break';
	
	equals = '=';
	
	l_par = '(';
	r_par = ')';
	l_bracket = '[';
	r_bracket = ']';
	l_brace = '{';
	r_brace = '}';
	comma = ',';
	semicolon = ';';
	
	address_of = '@';
	dereference = '#';
	
	plus = '+';
	minus = '-';
	
	complement = '~';
	to_bool = '?';
	not = '!';
	
	and = '&';
	or = '|';
	xor = '^';
	
	left_shift = '<<';
	right_shift = '>>';
	
	multiply = '*';
	divide = '/';
	modulo = '%';
	
	equal_to = '==';
	not_equal_to = '!=';
	less_than = '<';
	less_or_equal = '<=';
	more_than = '>';
	more_or_equal = '>=';
	
	name = nondigit char*;
	integer = sign? digit+;
	
	blank = separator+;
	comment = line_comment | block_comment;

Ignored Tokens
	blank,
	comment;

Productions
	unit =
		setup_section general_section*;
	
	
	
	/* UNIT SPECIFICATION */
	
	setup_section =
		input_specification?;
	
	input_specification =
		set_argc l_par expression r_par semicolon;
	
	general_section =
		{method_definition} method_definition |
		{function_definition} function_definition |
		{basic} basic_section;
	
	basic_section =
		{constant_definition} constant_definition |
		{variable_declaration} variable_declaration |
		{lvalue_modification} lvalue_modification |
		{method_call} method_call |
		{conditional} if_block else_if_block* else_block? |
		{iterative} iterative_block;
	
	
	
	/* SECTION SPECIFICATIONS */
	
	method_definition =
		void name l_par parameter_list? r_par l_brace basic_section* stop_statement? r_brace;
	
	function_definition =
		fun name l_par parameter_list? r_par l_brace basic_section* stop_statement? r_brace;
	
	constant_definition =
		const name equals expression semicolon;
	
	variable_declaration =
		{integer_no_initialisation} var declaration_variable semicolon |
		{integer_with_initialisation} var declaration_variable equals expression semicolon |
		{array_no_initialisation} var array_brackets+ declaration_variable semicolon |
		{array_with_implicit_initialisation} var array_brackets+ declaration_variable equals implicit_initialisation_array semicolon |
		{array_with_explicit_initialisation} var array_brackets+ declaration_variable equals explicit_initialisation_array semicolon;
	
	lvalue_modification =
		{integer_variable} lvalue_integer_variable equals expression semicolon |
		{array_element} lvalue_array_element equals expression semicolon |
		{par_array_element} par_lvalue_array_element equals expression semicolon;
	
	method_call =
		{built_in_out} out l_par expression r_par semicolon |
		{defined} name l_par argument_list? r_par semicolon;
	
	if_block =
		if l_par expression r_par l_brace basic_section* stop_statement? r_brace;
	
	else_if_block =
		else if l_par expression r_par l_brace basic_section* stop_statement? r_brace;
	
	else_block =
		else l_brace basic_section* stop_statement? r_brace;
	
	iterative_block =
		while l_par expression r_par l_brace basic_section* stop_statement? r_brace;
	
	stop_statement =
		{return} return semicolon dead_code* |
		{continue} continue semicolon dead_code* |
		{break} break semicolon dead_code* |
		{return_expression} return expression semicolon dead_code*;
	
	dead_code =
		{dead1} basic_section |
		{dead2} return semicolon |
		{dead3} continue semicolon |
		{dead4} break semicolon |
		{dead5} return expression semicolon;
	
	
	
	/* COMPONENT SPECIFICATIONS */
	
	expression =
		{prioritized} prioritized_expression |
		{binary} expression binary_op prioritized_expression;
	
	prioritized_expression =
		{term} term |
		{binary} prioritized_expression prioritized_binary_op term;
	
	term =
		{value} value |
		{address_of} address_of_term |
		{dereference} dereference_term |
		{unary} unary_op term |
		{par_expression} l_par expression r_par;
	
	address_of_term =
		{integer_variable} address_of rvalue_integer_variable |
		{array_element} address_of rvalue_array_element |
		{par_array_element} address_of par_rvalue_array_element;
	
	dereference_term =
		{integer_variable} dereference+ rvalue_integer_variable |
		{array_element} dereference+ rvalue_array_element |
		{par_array_element} dereference+ par_rvalue_array_element;
	
	value =
		{integer} integer |
		{integer_variable} rvalue_integer_variable |
		{array_element} rvalue_array_element |
		{function} function;
	
	function =
		{built_in_argc} argc l_par r_par |
		{built_in_argv} argv l_par expression r_par |
		{defined} name l_par argument_list? r_par;
	
	rvalue_integer_variable =
		name;
	
	rvalue_array_element =
		name array_brackets+;
	
	par_rvalue_array_element =
		l_par par_rvalue_array_element_internal r_par;
	
	par_rvalue_array_element_internal =
		dereference* name array_brackets+;
	
	lvalue_integer_variable =
		dereference* name;
	
	lvalue_array_element =
		dereference* name array_brackets+;
	
	par_lvalue_array_element =
		dereference+ l_par par_lvalue_array_element_internal r_par;
	
	par_lvalue_array_element_internal =
		dereference* name array_brackets+;
	
	declaration_variable =
		dereference* name;
	
	array_brackets =
		l_bracket expression r_bracket;
	
	implicit_initialisation_array =
		{address_of} address_of name array_brackets+ |
		{dereference} dereference* name array_brackets+;
	
	explicit_initialisation_array =
		{nested} l_brace explicit_initialisation_array_list r_brace |
		{non_nested} l_brace argument_list? r_brace;
	
	explicit_initialisation_array_list =
		explicit_initialisation_array explicit_initialisation_array_list_tail*;
	
	explicit_initialisation_array_list_tail =
		comma explicit_initialisation_array;
	
	argument_list =
		expression argument_list_tail*;
	
	argument_list_tail =
		comma expression;
	
	parameter_list =
		declaration_variable parameter_list_tail*;
	
	parameter_list_tail =
		comma declaration_variable;
	
	
	
	/* OPERATION SPECIFICATIONS */
	
	unary_op =
		{plus} plus |
		{minus} minus |
		{complement} complement |
		{to_bool} to_bool |
		{not} not;
	
	binary_op =
		{plus} plus |
		{and} and |
		{or} or |
		{xor} xor |
		{minus} minus;
	
	prioritized_binary_op =
		{left_shift} left_shift |
		{right_shift} right_shift |
		{multiply} multiply |
		{equal_to} equal_to |
		{divide} divide |
		{modulo} modulo |
		{not_equal_to} not_equal_to |
		{less_than} less_than |
		{less_or_equal} less_or_equal |
		{more_than} more_than |
		{more_or_equal} more_or_equal;
