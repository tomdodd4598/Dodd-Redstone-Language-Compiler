Package drlc;

Helpers
	all = [0 .. 0xFFFF];
	digit = ['0' .. '9'];
	letter = [['a' .. 'z'] + ['A' .. 'Z']];
	nondigit = ['_' + letter];
	char = digit | nondigit;
	sign = '-' | '+';
	
	tab = 9;
	lf = 10;
	cr = 13;
	eol = lf | cr | cr lf;
	separator = ' ' | tab | eol;
	
	double_slash = '//';
	slash_star = '/*';
	star_slash = '*/';
	
	not_eol = [all - [cr + lf]];
	not_star = [all - '*'];
	not_star_slash = [not_star - '/'];
	
	line_comment = double_slash not_eol* eol;
	block_comment = slash_star not_star* '*'+ (not_star_slash not_star* '*'+)* '/';

Tokens
	setup_prefix = '$';
	
	set_argc = 'set_argc';
	
	const = 'const';
	int = 'int';
	void = 'void';
	
	in = 'in';
	out = 'out';
	
	argc = 'argc';
	argv = 'argv';
	
	return = 'return';
	else = 'else';
	loop = 'loop';
	repeat = 'repeat';
	continue = 'continue';
	break = 'break';
	
	conditional_start_block_keyword = 'if' | 'unless';
	conditional_middle_block_keyword = 'elsif' | 'elsunless';
	conditional_iterative_block_keyword = 'while' | 'until';
	
	equals = '=';
	
	l_par = '(';
	r_par = ')';
	l_brace = '{';
	r_brace = '}';
	comma = ',';
	semicolon = ';';
	
	address_of = '@';
	dereference = '#';
	
	plus = '+';
	minus = '-';
	
	complement = '~';
	to_bool = '?';
	not = '!';
	
	and = '&';
	or = '|';
	xor = '^';
	
	left_shift = '<<';
	right_shift = '>>';
	
	multiply = '*';
	divide = '/';
	remainder = '%';
	
	equal_to = '==';
	not_equal_to = '!=';
	less_than = '<';
	less_or_equal = '<=';
	more_than = '>';
	more_or_equal = '>=';
	
	name = nondigit char*;
	integer = sign? digit+;
	
	blank = separator+;
	comment = line_comment | block_comment;

Ignored Tokens
	blank,
	comment;

Productions
	unit =
		setup_section general_section*;
	
	
	
	/* UNIT SPECIFICATION */
	
	setup_section =
		input_specification?;
	
	input_specification =
		setup_prefix set_argc l_par expression r_par semicolon;
	
	general_section =
		{method_definition} method_definition |
		{function_definition} function_definition |
		{basic} basic_section;
	
	basic_section =
		{constant_definition} constant_definition |
		{variable_declaration} variable_declaration |
		{variable_modification} variable_modification |
		{method_call} method_call |
		{conditional} conditional_section |
		{iterative} iterative_block;
	
	
	
	/* SECTION SPECIFICATIONS */
	
	method_definition =
		void name l_par parameter_list? r_par l_brace basic_section* stop_statement? r_brace;
	
	function_definition =
		int name l_par parameter_list? r_par l_brace basic_section* stop_statement? r_brace;
	
	constant_definition =
		const int name equals expression semicolon;
	
	variable_declaration =
		{no_initialisation} int lvalue_variable semicolon |
		{with_initialisation} int lvalue_variable equals expression semicolon;
	
	variable_modification =
		lvalue_variable equals expression semicolon;
	
	method_call =
		{built_in_out} out l_par expression r_par semicolon |
		{defined} name l_par argument_list? r_par semicolon;
	
	conditional_section =
		conditional_start_block conditional_middle_block* else_block?;
	
	conditional_start_block =
		conditional_start_block_keyword expression l_brace basic_section* stop_statement? r_brace;
	
	conditional_middle_block =
		conditional_middle_block_keyword expression l_brace basic_section* stop_statement? r_brace;
	
	else_block =
		else l_brace basic_section* stop_statement? r_brace;
	
	iterative_block =
		{loop} loop l_brace basic_section* stop_statement? r_brace |
		{conditional} conditional_iterative_block_keyword expression l_brace basic_section* stop_statement? r_brace |
		{repeat_conditional} repeat l_brace basic_section* stop_statement? r_brace conditional_iterative_block_keyword expression semicolon;
	
	stop_statement =
		{return} return semicolon dead_code* |
		{continue} continue semicolon dead_code* |
		{break} break semicolon dead_code* |
		{return_expression} return expression semicolon dead_code*;
	
	dead_code =
		{dead1} basic_section |
		{dead2} return semicolon |
		{dead3} continue semicolon |
		{dead4} break semicolon |
		{dead5} return expression semicolon;
	
	
	
	/* COMPONENT SPECIFICATIONS */
	
	expression =
		{prioritized} prioritized_expression |
		{binary} expression binary_op prioritized_expression;
	
	prioritized_expression =
		{term} term |
		{binary} prioritized_expression prioritized_binary_op term;
	
	term =
		{value} value |
		{address_of} address_of rvalue_variable |
		{dereference} dereference+ rvalue_variable |
		{unary} unary_op term |
		{par_expression} l_par expression r_par;
	
	value =
		{integer} integer |
		{variable} rvalue_variable |
		{function} function;
	
	function =
		{built_in_in} in l_par r_par |
		{built_in_argc} argc l_par r_par |
		{built_in_argv} argv l_par expression r_par |
		{defined} name l_par argument_list? r_par;
	
	rvalue_variable =
		name;
	
	lvalue_variable =
		dereference* name;
	
	argument_list =
		expression argument_list_tail*;
	
	argument_list_tail =
		comma expression;
	
	parameter_list =
		lvalue_variable parameter_list_tail*;
	
	parameter_list_tail =
		comma lvalue_variable;
	
	
	
	/* OPERATION SPECIFICATIONS */
	
	unary_op =
		{plus} plus |
		{minus} minus |
		{complement} complement |
		{to_bool} to_bool |
		{not} not;
	
	binary_op =
		{plus} plus |
		{and} and |
		{or} or |
		{xor} xor |
		{minus} minus;
	
	prioritized_binary_op =
		{left_shift} left_shift |
		{right_shift} right_shift |
		{multiply} multiply |
		{equal_to} equal_to |
		{divide} divide |
		{remainder} remainder |
		{not_equal_to} not_equal_to |
		{less_than} less_than |
		{less_or_equal} less_or_equal |
		{more_than} more_than |
		{more_or_equal} more_or_equal;
