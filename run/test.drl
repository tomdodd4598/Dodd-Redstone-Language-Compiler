// ITERATIVE FACTORIAL

/*
let f: Int = 1;
let a: Int = 1;
let b: Int = 1;

fn update() {
	f = a * b;
	b += 1;
	a = f;
}

while f > 0 {
	outint(f);
	update();
}
*/

// RECURSIVE FACTORIAL

/*
let f: Int = 1;
let i: Int = 1;

fn fact(n: Int) -> Int {
	if n <= 1 {
		return 1;
	}
	return n * fact(n - 1);
}

fn update() {
	i += 1;
	f = fact(i);
}

while f > 0 {
	outint(f);
	update();
}
*/

// ITERATIVE FIBONACCI

/*
%! setargc 2;

let f: Int = argv(0);
let a: Int = argv(1);
let b: Int = 0;

fn update() {
	f = a + b;
	b = a;
	a = f;
}

while f > 0 {
	outint(f);
	update();
}
*/

// RECURSIVE FIBONACCI

/*
%! setargc 2;

let f: Int = argv(0);
let i: Int = 0;

fn fib(n: Int) -> Int {
	if n <= 1 {
		return argv(n);
	}
	return fib(n - 1) + fib(n - 2);
}

fn update() {
	i += 1;
	f = fib(i);
}

while f > 0 {
	outint(f);
	update();
}
*/

// PRIME NUMBERS

/*
const MAX: Int = 100;
const FAIL: Int = MAX + 1;

let n: Int = 1;

fn sqrt(m: Int) -> Int {
	let a: Int = m;
	let b: Int = 1;
	
	while a > b {
		a = (a + b) >> 1;
		b = m / a;
	}
	
	return a;
}

while n < MAX {
	n += 1;
	let i: Int = 2;
	let s: Int = sqrt(n);
	
	while i <= s {
		if n % i == 0 {
			i = FAIL;
		}
		else {
			i += 1;
		}
	}
	
	if i != FAIL {
		outint(n);
	}
}
*/

// TESTING LITERALS

/*
let x: Int = 8 * 5 / 20;
let y: Int = 12 + 8 + 2 * x;
let z: Int = x * y - 6 + 10 / 5;

outint(z);
*/

// TESTING PRINTING

/*
let a: Char = 'H';
let b: Char = 'e';
let c: Char = 'l';
let d: Char = 'l';
let e: Char = 'o';
let f: Char = ' ';

let g: Char = 'W';
let h: Char = 'o';
let i: Char = 'r';
let j: Char = 'l';
let k: Char = 'd';
let l: Char = '!';
let m: Char = '\n';

outchar(a); outchar(b); outchar(c); outchar(d); outchar(e);
outchar(f);
outchar(g); outchar(h); outchar(i); outchar(j); outchar(k); outchar(l);
outchar(m);
*/

// TESTING BRANCHES

/*
fn func() {
	let a: Int = 0;
	let b: Int = 1;
	let c: Int = 2;
	
	if a == 0 {
		outint(1);
	}
	else unless b == 0 {
		outint(2);
	}
	
	if c == 0 {
		outint(3);
	}
	else {
		outint(4);
	}
	
	unless a == 1 {
		outint(5);
	}
	else if b == 1 {
		outint(6);
	}
	else {
		outint(7);
	}
	
	outer: loop {
		if c == 1 {
			outint(8);
		}
		else {
			inner: do {
				outint(9);
				break outer;
			}
			until c == 2;
		}
	}
}

func();
*/

// TESTING POINTERS

/*
let a: Int = 1;

let b_: Int = 2;
let b: &Int = &b_;

let c__: Int = 3;
let c_: &Int = &c__;
let c: &&Int = &c_;

fn update(x: &Int, y: &&Int, z: &&&Int) {
	*x = *x + 501;
	**y = **y + 502;
	***z = ***z + 503;
	
	*x -= 1;
	**y -= 2;
	***z -= 3;
}

update(&a, &b, &c);

//outint(&a);
outint(a);
//outint(&b); outint(b);
outint(*b);
//outint(&c); outint(c); outint(*c);
outint(**c);

let d: &Int = &a;

let e_: &&Int = &b;
let e: &&&Int = &e_;

let f__: &&&Int = &c;
let f_: &&&&Int = &f__;
let f: &&&&&Int = &f_;

fn update2(x: &&Int, y: &&&&Int, z: &&&&&&Int) {
	**x = 1001;
	****y = 1002;
	******z = 1003;
	
	**x *= 1;
	****y *= 2;
	******z *= 3;
}

update2(&d, &e, &f);

//outint(&d); outint(d);
outint(*d);
//outint(&e); outint(e); outint(*e); outint(**e);
outint(***e);
//outint(&f); outint(f); outint(*f); outint(**f); outint(***f); outint(****f);
outint(*****f);
*/

// TESTING DEREFERENCE ASSIGNMENT

/*
let a: &&&Int;

fn ptr1(modify: Bool) -> &Int {
	if modify {
		***a += 100;
	}
	return **a;
}

fn ptr2(modify: Bool) -> &&Int {
	if modify {
		***a -= 200;
	}
	return *a;
}

fn ptr3(modify: Bool) -> &&&Int {
	if modify {
		***a += 300;
	}
	return a;
}

*ptr1(true) = ***a + 50; outint(*ptr1(false));
*ptr1(true) <<= 1; outint(*ptr1(false));

**ptr2(true) = ***a + 100; outint(**ptr2(false));
**ptr2(true) >>= 2; outint(**ptr2(false));

***ptr3(true) = ***a + 150; outint(***ptr3(false));
***ptr3(true) /= 3; outint(***ptr3(false));
*/

// TESTING CONSTANTS AND SOFTWARE BINARY OPERATORS

/*
let l: Int = 0b11111111_00000000;
let r: Int = 0b00000000_11111111;

let a: Int = l;
let b: Int = r;

let a_sal: Int = l << 4;
let b_sal: Int = r << 4;

let a_sar: Int = l >> 4;
let b_sar: Int = r >> 4;

let a_shr: Int = l >>> 4;
let b_shr: Int = r >>> 4;

let a_rotl: Int = l <<< 4;
let b_rotl: Int = r <<< 4;

let a_rotr: Int = l >>> 4;
let b_rotr: Int = r >>> 4;

outint(a); outint(b);
outint(a_sal); outint(b_sal);
outint(a_sar); outint(b_sar);
outint(a_shr); outint(b_shr);
outint(a_rotl); outint(b_rotl);
outint(a_rotr); outint(b_rotr);
*/

// TESTING FUNCTION POINTERS


fn add(a: Int, b: Int) -> Int {
	return a + b;
}

fn subtract(a: Int, b: Int) -> Int {
	return a - b;
}

let print: fn(Bool);

fn multiply(a: Int, b: Int) -> Int {
	return a * b;
}

fn divide(a: Int, b: Int) -> Int {
	return a / b;
}

let i1: Int = 12;
let i2: Int = 4;

let s: Bool = false;

let binary_op_: fn(Int, Int) -> Int = subtract;
let binary_op: &fn(Int, Int) -> Int = &binary_op_;

fn get_op_ptr() -> &&fn(Int, Int) -> Int {
	return &binary_op;
}

print = outbool;

do_binary_op(&s, *choose_ptr(false, &i1, &i2), *choose_ptr(true, &i1, &i2), binary_op);
print(s);

if s {
	**get_op_ptr() = divide;
}

do_binary_op(&s, *choose_ptr(s, &i1, &i2), *choose_ptr(!s, &i1, &i2), binary_op);
print(s);

fn choose_ptr(cond: Bool, p1: &Int, p2: &Int) -> &Int {
	if cond {
		return p1;
	}
	else {
		return p2;
	}
}

fn do_binary_op(loc: &Bool, a: Int, b: Int, bin_op: &fn(Int, Int) -> Int) {
	*loc = int_to_bool(bin_op(a, b));
}

fn int_to_bool(x: Int) -> Bool {
	if x == 0 {
		return false;
	}
	else {
		return true;
	}
}

fn outbool(b: Bool) {
	if b {
		outint(1);
	}
	else {
		outint(0);
	}
}


// TESTING ARRAYS

/*
let a: Int = 1;
let b: Int = 2;
let c: Int = 3;

let arr: [[&Int; 2]; 3] = [[&a, &b], [&b, &c], [&c, &a]]; // Initialise array of arrays of integer pointers

let ptr: &[&Int; 2] = &arr[a]; // Initialise pointer to arrays of integer pointers

let num: Int = *ptr[1][2]; // Get an integer from the indexing the pointer, then indexing the array, and dereferencing the element
*/
