// ITERATIVE FACTORIAL

/*
fn main() {
	let mut f = 1;
	let mut a = 1;
	let mut b = 1;
	
	fn update() {
		f = a * b;
		b += 1;
		a = f;
	}
	
	while f > 0 {
		outint(f);
		update();
	}
}
*/

// RECURSIVE FACTORIAL

/*
fn fact(n: Int) -> Int {
	if n <= 1 {
		return 1;
	}
	return n * fact(n - 1);
}

fn main() {
	let mut f = 1;
	let mut i = 1;
	
	fn update() {
		i += 1;
		f = fact(i);
	}
	
	while f > 0 {
		outint(f);
		update();
	}
}
*/

// ITERATIVE FIBONACCI

/*
%! setargc 2;

fn main() {
	let mut f = argv[0];
	let mut a = argv[1];
	let mut b = 0;
	
	fn update() {
		f = a + b;
		b = a;
		a = f;
	}
	
	while f > 0 {
		outint(f);
		update();
	}
}
*/

// RECURSIVE FIBONACCI

/*
%! setargc 2;

fn fib(n: Int) -> Int {
	if n <= 1 {
		return argv[n];
	}
	return fib(n - 1) + fib(n - 2);
}

fn main() {
	let mut f = argv[0];
	let mut i = 0;
	
	fn update() {
		i += 1;
		f = fib(i);
	}
	
	while f > 0 {
		outint(f);
		update();
	}
}
*/

// PRIME NUMBERS

/*
const MAX = 100;
const FAIL = MAX + 1;

fn sqrt(m: Int) -> Int {
	let mut a = m;
	let mut b = 1;
	
	while a > b {
		a = (a + b) >> 1;
		b = m / a;
	}
	
	return a;
}

fn main() {
	let mut n = 1;
	
	while n < MAX {
		n += 1;
		let mut i = 2;
		let s = sqrt(n);
		
		while i <= s {
			if n % i == 0 {
				i = FAIL;
			}
			else {
				i += 1;
			}
		}
		
		if i != FAIL {
			outint(n);
		}
	}
}
*/

// TESTING LITERALS

/*
fn main () {
	let x = 8 * 5 / 20;
	let y = 12 + 8 + 2 * x;
	let z = x * y - 6 + 10 / 5;
	
	outint(z);
}
*/

// TESTING PRINTING

/*
let str = ['H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd', '!', '\n'];

fn main() {
	let mut i = 0;
	while i < 13 {
		outchar(str[i]);
		i += 1;
	}
}
*/

// TESTING BRANCHES

/*
fn main() {
	let a = 0;
	let b = 1;
	let c = 2;
	
	if a == 0 {
		outint(1);
	}
	else unless b == 0 {
		outint(2);
	}
	
	if c == 0 {
		outint(3);
	}
	else {
		outint(4);
	}
	
	unless a == 1 {
		outint(5);
	}
	else if b == 1 {
		outint(6);
	}
	else {
		outint(7);
	}
	
	outer: loop {
		if c == 1 {
			outint(8);
		}
		else {
			inner: do {
				outint(9);
				break outer;
			}
			until c == 2;
		}
	}
}
*/

// TESTING POINTERS

/*
let mut a = 1;
let mut b = &mut 2;
let mut c = &mut &mut 3;

let mut d = &mut a;
let mut e = &mut &mut b;
let mut f = &mut &mut &mut c;

fn update(x: &mut Int, y: &mut &mut Int, z: &mut &mut &mut Int) {
	*x = *x + 501;
	**y = **y + 502;
	***z = ***z + 503;
	
	*x -= 1;
	**y -= 2;
	***z -= 3;
}

fn update2(x: &mut &mut Int, y: &mut &mut &mut &mut Int, z: &mut &mut &mut &mut &mut &mut Int) {
	**x = 1001;
	****y = 1002;
	******z = 1003;
	
	**x *= 1;
	****y *= 2;
	******z *= 3;
}

fn main() {
	update(&mut a, &mut b, &mut c);
	
	//outint(&a);
	outint(a);
	//outint(&b); outint(b);
	outint(*b);
	//outint(&c); outint(c); outint(*c);
	outint(**c);
	
	update2(&mut d, &mut e, &mut f);
	
	//outint(&d); outint(d);
	outint(*d);
	//outint(&e); outint(e); outint(*e); outint(**e);
	outint(***e);
	//outint(&f); outint(f); outint(*f); outint(**f); outint(***f); outint(****f);
	outint(*****f);
}
*/

// TESTING DEREFERENCE ASSIGNMENT

/*
let a: &mut &mut &mut Int;

fn ptr1(modify: Bool) -> &mut Int {
	if modify {
		***a += 100;
	}
	return **a;
}

fn ptr2(modify: Bool) -> &mut &mut Int {
	if modify {
		***a -= 200;
	}
	return *a;
}

fn ptr3(modify: Bool) -> &mut &mut &mut Int {
	if modify {
		***a += 300;
	}
	return a;
}

fn main() {
	*ptr1(true) = ***a + 50; outint(*ptr1(false));
	*ptr1(true) <<= 1; outint(*ptr1(false));
	
	**ptr2(true) = ***a + 100; outint(**ptr2(false));
	**ptr2(true) >>= 2; outint(**ptr2(false));
	
	***ptr3(true) = ***a + 150; outint(***ptr3(false));
	***ptr3(true) /= 3; outint(***ptr3(false));
}
*/

// TESTING CONSTANTS AND SOFTWARE BINARY OPERATORS

/*
fn main() {
	let l = 0b11111111_00000000;
	let r = 0b00000000_11111111;
	
	let a = l;
	let b = r;
	
	let a_sal = l << 4;
	let b_sal = r << 4;
	
	let a_sar = l >> 4;
	let b_sar = r >> 4;
	
	let a_shr = l >>> 4;
	let b_shr = r >>> 4;
	
	let a_rotl = l <<< 4;
	let b_rotl = r <<< 4;
	
	let a_rotr = l >>> 4;
	let b_rotr = r >>> 4;
	
	outint(a); outint(b);
	outint(a_sal); outint(b_sal);
	outint(a_sar); outint(b_sar);
	outint(a_shr); outint(b_shr);
	outint(a_rotl); outint(b_rotl);
	outint(a_rotr); outint(b_rotr);
}
*/

// TESTING FUNCTION POINTERS

/*
let mut binary_op = &mut subtract;

fn get_op_ptr() -> &mut &mut fn(Int, Int) -> Int {
	return &mut binary_op;
}

fn main() {
	let mut print: fn(Bool);
	
	let i1 = 12;
	let i2 = 4;
	
	let mut s = false;
	
	print = outbool;
	do_binary_op(&mut s, *choose_ptr(false, &i1, &i2), *choose_ptr(true, &i1, &i2), binary_op);
	print(s);
	
	if s {
		**get_op_ptr() = divide;
	}
	
	do_binary_op(&mut s, *choose_ptr(s, &i1, &i2), *choose_ptr(!s, &i1, &i2), binary_op);
	print(s);
}

fn add(a: Int, b: Int) -> Int {
	return a + b;
}

fn subtract(a: Int, b: Int) -> Int {
	return a - b;
}

fn multiply(a: Int, b: Int) -> Int {
	return a * b;
}

fn divide(a: Int, b: Int) -> Int {
	return a / b;
}

fn choose_ptr(cond: Bool, p1: &Int, p2: &Int) -> &Int {
	if cond {
		return p1;
	}
	else {
		return p2;
	}
}

fn do_binary_op(loc: &mut Bool, a: Int, b: Int, bin_op: &fn(Int, Int) -> Int) {
	*loc = int_to_bool((*bin_op)(a, b));
}

fn int_to_bool(x: Int) -> Bool {
	if x == 0 {
		return false;
	}
	else {
		return true;
	}
}
*/

// TESTING ARRAYS

/*
fn main () {
	let a = 1;
	let b = 2;
	let mut c = 3;
	
	let mut arr = [[&a, &b], [&b, &c], [&c, &a]];
	
	let ptr = &arr[a];
	
	let num = *ptr[1][1];
	
	arr[2][1] = &b;
	
	arr[1] = [&1, &2];
	
	c = 4;
}
*/

// TESTING TYPEALIASES

/*
fn main() {
	outint(sum(&&(1, 2, 3)));
	
	fn sum(ptr: &PosPtr) -> Int {
		let p = *ptr;
		return (*p).0 + (*p).1 + (*p).2;
	}
}

typealias PosPtr = &(Int, Int, Int);
*/

// TESTING STRUCTS

/*
struct Item {
	val: Int,
	next: &mut Item,
}

typealias Tracer = &&mut Item;
typealias TracerMut = &mut &mut Item;

fn insertItem(mut tracer: TracerMut, val: Int) {
	while *tracer != null && val >= (**tracer).val {
		tracer = &mut (**tracer).next;
	}
	
	*tracer = &mut Item { val, *tracer };
}

fn removeItem(mut tracer: TracerMut, val: Int) {
	while *tracer != null && val != (**tracer).val {
		tracer = &mut (**tracer).next;
	}
	
	if *tracer != null {
		*tracer = (**tracer).next;
	}
}

fn print(mut tracer: Tracer) {
	while *tracer != null {
		outint((**tracer).val);
		tracer = &(**tracer).next;
	}
}

fn main() {
	let mut start: &mut Item = null;
	
	insertItem(&mut start, 3);
	insertItem(&mut start, 6);
	insertItem(&mut start, 2);
	insertItem(&mut start, 1);
	insertItem(&mut start, 4);
	insertItem(&mut start, 7);
	insertItem(&mut start, 2);
	insertItem(&mut start, 5);

	print(&start);

	removeItem(&mut start, 4);
	removeItem(&mut start, 7);
	removeItem(&mut start, 2);

	print(&start);
}
*/

// TESTING 
