// ITERATIVE FACTORIAL

/*
fn main() {
	let mut f = 1;
	let mut a = 1;
	let mut b = 1;
	
	fn update() {
		f = a * b;
		b += 1;
		a = f;
	}
	
	while f > 0 {
		printInt(f);
		update();
	}
}
*/

// RECURSIVE FACTORIAL

/*
fn fact(n: Int) -> Int {
	if n <= 1 {
		return 1;
	}
	return n * fact(n - 1);
}

fn main() {
	let mut f = 1;
	let mut i = 1;
	
	fn update() {
		i += 1;
		f = fact(i);
	}
	
	while f > 0 {
		printInt(f);
		update();
	}
}
*/

// ITERATIVE FIBONACCI

/*
fn main() {
	let mut f = argv[0];
	let mut a = argv[1];
	let mut b = 0;
	
	fn update() {
		f = a + b;
		b = a;
		a = f;
	}
	
	while f > 0 {
		printInt(f);
		update();
	}
}
*/

// RECURSIVE FIBONACCI

/*
fn fib(n: Int) -> Int {
	if n <= 1 {
		return argv[n];
	}
	return fib(n - 1) + fib(n - 2);
}

fn main() {
	let mut f = argv[0];
	let mut i = 0;
	
	fn update() {
		i += 1;
		f = fib(i);
	}
	
	while f > 0 {
		printInt(f);
		update();
	}
}
*/

// PRIME NUMBERS

/*
const MAX = 100;
const FAIL = MAX + 1;

fn sqrt(m: Int) -> Int {
	let mut a = m;
	let mut b = 1;
	
	while a > b {
		a = (a + b) >> 1;
		b = m / a;
	}
	
	return a;
}

fn main() {
	let mut n = 1;
	
	while n < MAX {
		n += 1;
		let mut i = 2;
		let s = sqrt(n);
		
		while i <= s {
			if n % i == 0 {
				i = FAIL;
			}
			else {
				i += 1;
			}
		}
		
		if i != FAIL {
			printInt(n);
		}
	}
}
*/

// TESTING LITERALS

/*
fn main () {
	let x = 8 * 5 / 20;
	let y = 12 + 8 + 2 * x;
	let z = x * y - 6 + 10 / 5;
	
	printInt(z);
}
*/

// TESTING PRINTING

/*
let str = ['H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd', '!', '\n'];

fn main() {
	let mut i = 0;
	while i < 13 {
		printChar(str[i]);
		i += 1;
	}
}
*/

// TESTING BRANCHES

/*
fn main() {
	let a = 0;
	let b = 1;
	let c = 2;
	
	if a == 0 {
		printInt(1);
	}
	else unless b == 0 {
		printInt(2);
	}
	
	if c == 0 {
		printInt(3);
	}
	else {
		printInt(4);
	}
	
	unless a == 1 {
		printInt(5);
	}
	else if b == 1 {
		printInt(6);
	}
	else {
		printInt(7);
	}
	
	outer: loop {
		if c == 1 {
			printInt(8);
		}
		else {
			inner: do {
				printInt(9);
				break outer;
			}
			until c == 2;
		}
	}
}
*/

// TESTING POINTERS

/*
let mut a = 1;
let mut b = &mut 2;
let mut c = &mut &mut 3;

let mut d = &mut a;
let mut e = &mut &mut b;
let mut f = &mut &mut &mut c;

fn update(x: &mut Int, y: &mut &mut Int, z: &mut &mut &mut Int) {
	*x = *x + 501;
	**y = **y + 502;
	***z = ***z + 503;
	
	*x -= 1;
	**y -= 2;
	***z -= 3;
}

fn update2(x: &mut &mut Int, y: &mut &mut &mut &mut Int, z: &mut &mut &mut &mut &mut &mut Int) {
	**x = 1001;
	****y = 1002;
	******z = 1003;
	
	**x *= 1;
	****y *= 2;
	******z *= 3;
}

fn main() {
	update(&mut a, &mut b, &mut c);
	
	//printInt(&a);
	printInt(a);
	//printInt(&b); printInt(b);
	printInt(*b);
	//printInt(&c); printInt(c); printInt(*c);
	printInt(**c);
	
	update2(&mut d, &mut e, &mut f);
	
	//printInt(&d); printInt(d);
	printInt(*d);
	//printInt(&e); printInt(e); printInt(*e); printInt(**e);
	printInt(***e);
	//printInt(&f); printInt(f); printInt(*f); printInt(**f); printInt(***f); printInt(****f);
	printInt(*****f);
}
*/

// TESTING DEREFERENCE ASSIGNMENT

/*
let a: &mut &mut &mut Int;

fn ptr1(modify: Bool) -> &mut Int {
	if modify {
		***a += 100;
	}
	return **a;
}

fn ptr2(modify: Bool) -> &mut &mut Int {
	if modify {
		***a -= 200;
	}
	return *a;
}

fn ptr3(modify: Bool) -> &mut &mut &mut Int {
	if modify {
		***a += 300;
	}
	return a;
}

fn main() {
	*ptr1(true) = ***a + 50; printInt(*ptr1(false));
	*ptr1(true) <<= 1; printInt(*ptr1(false));
	
	**ptr2(true) = ***a + 100; printInt(**ptr2(false));
	**ptr2(true) >>= 2; printInt(**ptr2(false));
	
	***ptr3(true) = ***a + 150; printInt(***ptr3(false));
	***ptr3(true) /= 3; printInt(***ptr3(false));
}
*/

// TESTING CONSTANTS AND SOFTWARE BINARY OPERATORS

/*
fn main() {
	let l = 0b11111111_00000000;
	let r = 0b00000000_11111111;
	
	let a = l;
	let b = r;
	
	let a_sal = l << 4;
	let b_sal = r << 4;
	
	let a_sar = l >> 4;
	let b_sar = r >> 4;
	
	let a_shr = l >>> 4;
	let b_shr = r >>> 4;
	
	let a_rotl = l <<< 4;
	let b_rotl = r <<< 4;
	
	let a_rotr = l >>> 4;
	let b_rotr = r >>> 4;
	
	printInt(a); printInt(b);
	printInt(a_sal); printInt(b_sal);
	printInt(a_sar); printInt(b_sar);
	printInt(a_shr); printInt(b_shr);
	printInt(a_rotl); printInt(b_rotl);
	printInt(a_rotr); printInt(b_rotr);
}
*/

// TESTING FUNCTION POINTERS

/*
let mut binary_op = &mut subtract;

fn get_op_ptr() -> &mut &mut fn(Int, Int) -> Int {
	return &mut binary_op;
}

fn main() {
	let mut print: fn(Bool);
	
	let i1 = 12;
	let i2 = 4;
	
	let mut s = false;
	
	print = printBool;
	do_binary_op(&mut s, *choose_ptr(false, &i1, &i2), *choose_ptr(true, &i1, &i2), binary_op);
	print(s);
	
	if s {
		**get_op_ptr() = divide;
	}
	
	do_binary_op(&mut s, *choose_ptr(s, &i1, &i2), *choose_ptr(!s, &i1, &i2), binary_op);
	print(s);
}

fn add(a: Int, b: Int) -> Int {
	return a + b;
}

fn subtract(a: Int, b: Int) -> Int {
	return a - b;
}

fn multiply(a: Int, b: Int) -> Int {
	return a * b;
}

fn divide(a: Int, b: Int) -> Int {
	return a / b;
}

fn choose_ptr(cond: Bool, p1: &Int, p2: &Int) -> &Int {
	if cond {
		return p1;
	}
	else {
		return p2;
	}
}

fn do_binary_op(loc: &mut Bool, a: Int, b: Int, bin_op: &fn(Int, Int) -> Int) {
	*loc = int_to_bool((*bin_op)(a, b));
}

fn int_to_bool(x: Int) -> Bool {
	if x == 0 {
		return false;
	}
	else {
		return true;
	}
}
*/

// TESTING ARRAYS

/*
fn main () {
	let a = 1;
	let b = 2;
	let mut c = 3;
	
	let mut arr = [[&a, &b], [&b, &c], [&c, &a]];
	
	let ptr = &arr[a];
	
	let num = *ptr[1][1];
	
	arr[2][1] = &b;
	
	arr[1] = [&1, &2];
	
	c = 4;
}
*/

// TESTING TYPEALIASES

/*
fn main() {
	printInt((1, 2, 3).sum());
	
	fn sum(ptr: &PosPtr) -> Int {
		let p = *ptr;
		return p.0 + p.1 + p.2;
	}
}

alias PosPtr = &(Int, Int, Int);
*/

// TESTING STRUCTS

/*
struct Thing {
	item: Chars,
	next: &mut Thing,
}

alias Node = &mut Thing;
alias Tracer = &mut Node;

fn compareChars(x: Chars, y: Chars) -> Int {
	let mut i = 0N;
	let lim = x.len < y.len ? x.len : y.len;
	while i < lim {
		let cx = x.ptr[i];
		let cy = y.ptr[i];
		if cx != cy {
			return (cx - cy) as Int;
		}
		i += 1;
	}
	
	return (x.len - y.len) as Int;
}

fn printChars(chars: Chars) {
	let mut i = 0N;
	while i < chars.len {
		printChar(chars.ptr[i]);
		i += 1;
	}
}

fn newElement(item: Chars) -> Node {
	let static mut arr = [Thing { "", null }; 8];
	let static mut i = 0N;
	
	let node = &mut arr[i];
	*node = Thing { item, null };
	i += 1;
	return node;
}

fn deleteElement(node: Node) {
	*node = Thing { "", null };
}

fn insertThing(mut tracer: Tracer, mut elem: Node) {
	while *tracer != null && compareChars(tracer.item, elem.item) < 1 {
		tracer = &mut tracer.next;
	}
	
	elem.next = *tracer;
	*tracer = elem;
}

fn removeThing(mut tracer: Tracer, item: Chars) {
	while *tracer != null && compareChars(tracer.item, item) != 0 {
		tracer = &mut tracer.next;
	}
	
	if *tracer != null {
		let old = *tracer;
		*tracer = tracer.next;
		deleteElement(old);
	}
}

fn printList(mut node: Node) {
	while node != null {
		printChars(node.item);
		printChar('\n');
		node = node.next;
	}
}

fn main() {
	let mut start = null as Node;
	
	start.insertThing(newElement("chips"));
	start.insertThing(newElement("wine"));
	start.insertThing(newElement("burgers"));
	start.insertThing(newElement("beer"));
	start.insertThing(newElement("pizza"));
	start.insertThing(newElement("zucchini"));
	start.insertThing(newElement("burgers"));
	start.insertThing(newElement("slaw"));

	printChars("\nInitial List:\n");
	start.printList();

	start.removeThing("pizza");
	start.removeThing("zucchini");
	start.removeThing("burgers");

	printChars("\nAltered List:\n");
	start.printList();
}
*/

fn main() {
	//struct Pos { x: Char, y: Char, z: Char };
	//let pos = &mut Pos { '1', '2', '3' };
	//(*pos).y = (*pos).z;
	let arr = &mut ['1', '2', '3'];
	(*arr)[1] = (*arr)[2];
}
